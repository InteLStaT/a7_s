package org.ucoz.intelstat.a7.core;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.concurrent.TimeUnit;

import org.ucoz.intelstat.gc.GCard;
import org.ucoz.intelstat.gc.GDeck;
import org.ucoz.intelstat.gc.GHand;

/**
 * Encapsulates an America 7 game on the server side, without doing any
 * networking. Players can join the game by creating an instance of the nested
 * class {@code Player}. A game can have anywhere from 2 to 6 players, although
 * 5- or 6-player games are considered non-standard.
 * 
 * @author InteLStaT
 *
 */
// TODO: THROW EXCEPTIONS IN APPROPRIATE GETTERS IF THE GAME HASN'T STARTED
public class Game {

	private static final int AWAIT_GED_TIME = 500;

	public static final int INITIAL_HAND_SIZE = 5;
	public static final int MIN_PLAYER_COUNT = 2;
	public static final int MAX_PLAYER_COUNT = 6;
	private static final IllegalGameStateException PREGAME_EXCEPTION = new IllegalGameStateException(
			"The game hasn't started yet", GameState.PREGAME);
	private static final IllegalGameStateException INGAME_EXCEPTION = new IllegalGameStateException(
			"The game has already started", GameState.INGAME);
	private static final IllegalGameStateException POSTGAME_EXCEPTION = new IllegalGameStateException(
			"The game has already ended", GameState.POSTGAME);

	private Player[] players;
	private int playerCount;

	/**
	 * The deck from which cards are dealt to players and are drawn from.
	 */
	private GDeck drawDeck;
	/**
	 * The pile in which cards are put into.
	 */
	private List<GCard> pile;
	/**
	 * The top card in the pile.
	 */
	private GCard topCard;

	/**
	 * Current state of the game.
	 * 
	 * @see GameState
	 */
	private GameState gameState = GameState.PREGAME;
	/**
	 * A round consists of all players' turns. Therefore it is incremented
	 * whenever all players have made a move.
	 */
	private int round;
	/**
	 * The current player being asked to make a move.
	 */
	private Player curPlayer;
	/**
	 * Index of the current player in the getPlayers() array.
	 * 
	 * @see Game#curPlayer
	 */
	private int curPlayerIdx;
	/**
	 * Winner of the game.
	 */
	private Player winner;
	/**
	 * Listeners for GED.
	 */
	private List<GameListener> listeners = new ArrayList<>(2);
	/**
	 * Dictates the flow of the game. Wow what a description.
	 */
	private GameLoop gameLoop;
	private Thread gameLoopThread;
	/**
	 * Dispatches events generated by the game.
	 */
	private static GameEventDispatcher ged;

	// TODO: let the server manage GEDs. Too many games will likely cause
	// delays.
	static {
		ged = new GameEventDispatcher();
		ged.start();
	}

	public Game() {
		players = new Player[6];
		drawDeck = GDeck.shuffledDeck();
		pile = new ArrayList<>(32);
		gameLoopThread = new Thread(gameLoop = new GameLoop());
	}

	public void addGameListener(GameListener l) {
		listeners.add(l);
	}

	public void removeGameListener(GameListener l) {
		listeners.remove(l);
	}

	public GameState getGameState() {
		return gameState;
	}

	public Player getStartingPlayer() throws IllegalGameStateException {
		_checkPregameException();
		return getPlayers()[0];
	}

	public Player getCurrentPlayer() throws IllegalGameStateException {
		_checkPregameException();
		return curPlayer;
	}

	public Player[] getPlayers() {
		return players;
	}

	/**
	 * Returns the deck's size from which cards are drawn by players.
	 * A value of 32 indicates the game hasn't started yet.
	 */
	// TODO: check pregame exception or not? if yes, remove doc
	public int getDrawDeckSize() {
		return drawDeck.getSize();
	}

	public GCard getTopCard() throws IllegalGameStateException {
		_checkPregameException();
		return topCard;
	}

	public int getRound() throws IllegalGameStateException {
		_checkPregameException();
		return round;
	}

	public Player getWinner() throws IllegalGameStateException {
		if (getGameState() != GameState.POSTGAME) {
			throw getGameState() == GameState.PREGAME ? PREGAME_EXCEPTION : POSTGAME_EXCEPTION;
		}
		return winner;
	}

	public void start() throws IllegalGameStateException {
		if (gameState == GameState.PREGAME) {
			if (playerCount >= MIN_PLAYER_COUNT && playerCount <= MAX_PLAYER_COUNT) {

				// RANDOMIZE PLAYERS
				Random rgen = new Random();
				for (int i = 0; i < playerCount; i++) {
					int rand = rgen.nextInt(playerCount);
					Player temp = players[i];
					players[i] = players[rand];
					players[rand] = temp;
				}

				// PLAYER SETUP
				for (int i = 0; i < playerCount; i++) {
					players[i].setIndex(i);
					drawDeck.dealTo(players[i].getHand(), 5);
				}

				// GAME SETUP
				topCard = drawDeck.dealCard();
				putInPile(topCard);

				// Pause for a second... no way the game is already starting!
				_sleep(1000);

				gameState = GameState.INGAME;
				/* EVENT */gameLoop
						.gameStateChanged(new GamePassiveEvent(this, null, round, GameState.PREGAME, gameState));

				// Dem best part of this whole thing
				gameLoopThread.start();
			} else {
				throw new IllegalStateException("Player count isn't between allowed bounds");
			}
		} else {
			throw getGameState() == GameState.INGAME ? INGAME_EXCEPTION : POSTGAME_EXCEPTION;
		}
	}

	private void putInPile(GCard card) {
		pile.add(card);
	}

	private void _sleep(long millis) {
		try {
			Thread.sleep(millis);
		} catch (InterruptedException e) {
			System.err.println("SLEEP METHOD INTERRUPTED");
		}
	}

	private void _awaitGED() {
		_sleep(AWAIT_GED_TIME);
	}

	private void _checkPregameException() throws IllegalGameStateException {
		if(getGameState() == GameState.PREGAME) {
			throw PREGAME_EXCEPTION;
		}
	}
	
	public class Player {

		private final String name;
		private boolean ready = false;

		private int index;

		private Controller ctrl;

		private GHand hand;

		public Player(String name, Controller ctrl) {
			if (gameState == GameState.PREGAME) {
				if (playerCount <= MAX_PLAYER_COUNT) {
					players[playerCount] = this;
					playerCount++;
				} else {
					throw new IllegalStateException("Player count exceeded " + MAX_PLAYER_COUNT + ". Can't add more");
				}
			} else {
				throw getGameState() == GameState.INGAME ? INGAME_EXCEPTION : POSTGAME_EXCEPTION;
			}
			hand = new GHand();
			this.name = name;
			this.ctrl = ctrl;
			/* EVENT */ged.invokeLater(() -> ctrl.init(this));
			/* EVENT */gameLoop.playerJoined(new GamePassiveEvent(Game.this, this, round, gameState, gameState));
		}

		// TODO: do something with the ready up system
		public void readyUp() {
			ready = true;
		}

		public Game getGame() {
			return Game.this;
		}

		public String getName() {
			return name;
		}

		public int getCardCount() {
			return hand.getSize();
		}

		/**
		 * Returns this player's index in the Game.getPlayers() array. The index
		 * of players in the PREGAME state is unknown.
		 * 
		 * @throws IllegalGameStateException
		 *             if the game hasn't started yet
		 */
		public int getIndex() {
			if (getGameState() != GameState.PREGAME) {
				return index;
			} else {
				throw PREGAME_EXCEPTION;
			}
		}

		private void setIndex(int idx) {
			index = idx;
		}

		private GCard requestCard() {
			return ctrl.proposeCard(topCard, hand, getGame(), this);
		}

		private GHand getHand() {
			return hand;
		}

	}

	private int underStreak;
	private int aceStreak;

	// I very much like public interface methods. Not like anybody's gonna get
	// access to it.
	// I will disable reflection anyways.
	// TODO: disable reflection.
	private class GameLoop implements Runnable, GameListener {

		/***************
		 * GAME LOOP *
		 ***************/
		// TODO: still mess, but more mess. please make less mess.
		public void run() {
			// Set up first player
			curPlayer = getPlayers()[0];
			curPlayerIdx = curPlayer.getIndex();
			assert curPlayerIdx == 0;
			/* EVENT */currentPlayerChanged(new GamePassiveEvent(Game.this, curPlayer, round, gameState, gameState));

		}

		/************************
		 * EVENT FIRING METHODS *
		 ************************/
		@Override
		public void playerJoined(GamePassiveEvent e) {
			System.err.println("  \033[31m+Player joined\033[0m");
			System.err.println("  \033[33m└─Event dispatched to " + listeners.size() + "\033[0m");
			ged.postEvent(listeners, (l) -> l.playerJoined(e));
		}

		@Override
		public void playerLeft(GamePassiveEvent e) {
			ged.postEvent(listeners, (l) -> l.playerLeft(e));
		}

		@Override
		public void currentPlayerChanged(GamePassiveEvent e) {
			ged.postEvent(listeners, (l) -> l.currentPlayerChanged(e));
		}

		@Override
		public void gameStateChanged(GamePassiveEvent e) {
			ged.postEvent(listeners, (l) -> l.gameStateChanged(e));
		}

		@Override
		public void playerCardCountChanged(GameQuantitativeEvent e, Player player) {
			System.err.println("  \033[31m+Card count changed\033[0m");
			System.err.println("  \033[33m└─Event dispatched to " + listeners.size() + "\033[0m");
			ged.postEvent(listeners, (l) -> l.playerCardCountChanged(e, player));
		}

		@Override
		public void roundChanged(GameQuantitativeEvent e) {
			System.err.println("  \033[31m+Round changed\033[0m");
			System.err.println("  \033[33m└─Event dispatched to " + listeners.size() + "\033[0m");
			ged.postEvent(listeners, (l) -> l.roundChanged(e));
		}

		@Override
		public void deckRefilled(Game game) {
			ged.postEvent(listeners, (l) -> l.deckRefilled(game));
		}

		@Override
		public void deckSizeDecreased(GameQuantitativeEvent e) {
			ged.postEvent(listeners, (l) -> l.deckSizeDecreased(e));
		}

		@Override
		public void pileSizeIncreased(GameQuantitativeEvent e) {
			ged.postEvent(listeners, (l) -> l.pileSizeIncreased(e));
		}

	}

}
